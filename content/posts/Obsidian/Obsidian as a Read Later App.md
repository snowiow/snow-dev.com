---
date: 2025-07-16
tags:
  - obsidian
title: Obsidian as a Read Later App
---
I was a long-time [Pocket](https://getpocket.com/farewell) user. I used it to store articles from newsletters or my feed and it was my central hub where I looked if I wanted to read something. But at the end of May 2025, Mozilla announced that they will [shut down](https://support.mozilla.org/en-US/kb/future-of-pocket#w_why-is-pocket-shutting-down) Pocket on the 8th of July. Afterwards, a lot of posts popped up which showed off different alternatives, but nothing really caught my interest. I'm a big fan of getting most of my stuff done in as few applications as possible and therefore I was looking around if one of my existing tools can do the job. This is when I learned about [Obsidian Web Clipper](https://obsidian.md/clipper). 

# Meet Obsidian Web Clipper
Obsidian Web Clipper is a browser extension that lets you capture web pages and store them in your Obsidian vault. This was the one piece I was missing in all the other tools I'm actively using, that would let me convert it into a read later app. The extension is available for most Browsers that support Plugins. I'm using Firefox and it looks like this:
![[img/obsidian_as_a_read_later_app_web_clipper.png]]
It adds a small icon, which you can click and you are presented with a little popup which shows you what Obsidian Web Clipper will be creating as an Obsidian Note. There is a default template which pre-fills a ton of properties already. But you can also configure your own, which I did. You also get a preview of the extracted text. Most of the time, Obsidian Web Clipper is very good at extracting the original content, but there are some websites where it wasn't able to. But those have only been rare cases so far. Last but not least you see the path in your vault, where the note would be stored and a button to actually save it.

There are a lot more features, like highlighting, but this default template and storing the whole website content is all I use. If I want to store something I click the Obsidian Symbol next to the address bar, look if the text would get extracted correctly and click *Add to Obsidian*. That's it. 

Now let's talk about the tags I add on top of the default ones. If you click on the cog on the top right you get to the settings. Then click on the default Template on the left and you should end up here
![[obsidian_as_a_read_later_app_web_clipper_settings.png]]
Here you can edit your default path, which I set to a dedicated read later directory and the properties. I changed the tags to `read-later`. I added a property which always sets *read: false*, which I'll explain later. Finally, I added a read time property which shows off the coolest features of Obsidian Web Clipper: [**Variables**](https://help.obsidian.md/web-clipper/variables) & [**Filters**](https://help.obsidian.md/web-clipper/filters). With them you can do very powerful stuff. I for example want to know how long it would take me to read an article before I start reading it, because whenever I'm going somewhere, I would like to finish what I'm reading before I arrive. So I used variables & filters to get an estimate read time in minutes. This is nothing special, but a very basic calculation, which served me quite well so far. This is the whole expression:
```
{{content|split:" "|length|calc:"/200"|round}} minutes
```
Let's break it down!
First, I use the `content` variable to get the whole content of an article. Then I use `|` to apply a filter to the content variable. In this case, I want to `split` the `content` whenever there is a space. Now I have an array of words. The most beautiful thing is, you can chain filters onto each other, similar to how you would use function composition in a functional programming language. What I do next is apply another filter to the result of my previous operation, which is the array of space-separated words. I take the `length` of the array. Then I use the `calc` filter to do a calculation with the length of the words array. Filters can also have parameters. When they do, they are introduced with a `:` and then a parameter value. In a normal programming language the call would look like this: `650.calc("/200")`  if we would have an article consisting of 650 words. So I divide the amount of words by 200. This is based on the assumption that I read about 200 words per minute, because I'm a very slow reader. Normal reading speeds can range all the way between 200 and 400. Depending on how fast you read, substitute it with your words per minute. Finally, we `round` the value to whole numbers, which means we have a full minute value without decimals. `round` can also take parameters like this `round:2`, which would round to 2 values after the comma. If you want to have a more accurate reading time, you can do so. Finally, I wrote 'minutes' after the `{{ }}` expression. This is just a normal string which is appended to the calculated value. So in the end, the value that would be set for my *read time* property is *3 minutes* if we continue to use the example of having a 650-word article.

Now that we can store articles in Obsidian to read later, we have a folder full of notes but how do we know what to read next? Let's create an overview!
# Meet Bases
I think this is also possible to do with *dataview*, but I chose to go with the new core plugin Bases. It is already available in the [Catalyst license](https://help.obsidian.md/catalyst) and it's easy to use and a great fit for what we want to do. Via the command palette and choosing *Bases: Create new base*, we can create a new Bases file. Let's name it Read Later. It should also show a BASE icon next to the name. In the file, you probably see a table with one column and a lot of items. This is because you haven't set any filters yet. Let's do this now! This is also where the *read* property comes into play. Because we only want to show notes in our Bases table which are not read yet and which have the tag `#read-later`. In Bases, this looks like this:
![[obsidian_as_a_read_later_app_bases.png]]
As you can see, we just need to click on Filter and then define our two filters. Also, we can sort our list by the date the article was published. In case you have properties shown as columns that you don't want, you can click those as well via the Properties field on the top right. I decided to show the article name, the published date and the read time field we created with variables and filters. 

And with this, we have already reached our goal. From this overview, I normally choose the oldest articles, which are normally those that I have stored the longest already and which have a fitting read time. When I'm done with an article, I usually do one of two things. Either I want to keep the article for later reference. Then I update the *read* property to 'true'. That way, it doesn't show up in my read-later table anymore, or I delete the note to not spam my vault with too many things I won't read again anyway.